[[r_git_branches_overview]]
=== Branches em poucas Palavras

Para realmente entender como o Git trabalha com _branches_ (ramos), precisamos dar um passo para trás e entender como ele armazena seus dados.

Como talvez você se lembre de <<ch01-introduction#ch01-introduction>>, o Git não armazena dados como uma série de alterações ou diferenças, mas como uma série de imagens (_snapshots_).

Quando você cria um _commit_, o Git guarda um objeto _commit_ que aponta para o _snapshot_ do conteúdo que você adicionou à área de _stage_.
Este objeto também contém o nome e email do autor, a mensagem que foi escrita, e aponta para o _commit_ ou _commits_ que vieram diretamente antes deste _commit_ (seu pai ou seus pais): nenhum pai para o _commit_ inicial, um pai para um _commit_ normal, ou múltiplos pais para um _commit_ que é resultado de mesclagem (_merge_) de duas ou mais _branches_.

Para visualizar isto, vamos assumir que você tenha um diretório que contém 3 arquivos, você adiciona todos eles à área de _stage_ e cria um _commit_.
Para cada arquivo que é adicionado à área de _stage_, é calculado seu _checksum_ (o hash SHA-1 que mencionamos em <<ch01-introduction#ch01-introduction>>), essa versão do arquivos é armazenada no repositório do Git (Git se refere a ele como _blob_), e adiciona esse _checksum_ à área de _stage_:

[source,console]
----
$ git add README test.rb LICENSE
$ git commit -m 'The initial commit of my project'
----

Quando vocẽ cria um _commit_ executando `git commit`, o Git calcula o _checksum_ de cada subdiretório (neste caso, apenas o diretório raiz), e armazena os objetos do tipo _tree_ no repositório Git.
O Git então cria um _commit_ que contém os metadados e uma referência para a _tree_ raiz do projeto, então ele pode recriar o _snapshot_ assim que precisar.(((git commands, commit)))

Seu reposítorio Git agora contém cinco objetos: um objeto _blob_ para os conteúdos de cada um dos três arquivos, um objeto _tree_ que lista os conteúdos do diretório e especifica quais nomes de arquivos são gravados para cada _blob_, e um _commit_ que contém seus metadados e uma referencia para a _tree_ raiz.

.Um _commit_ e sua _tree_
image::images/commit-and-tree.png[A commit and its tree.]

Se você fizer algumas alterações e fizer um novo _commit_, ele irá armazenar uma referência para o _commit_ que veio imediatamente antes.

.Commits e seus pais
image::images/commits-and-parents.png[Commits and their parents.]

Uma _branch_ no git é simplesmente uma referência móvel para um desses _commits_.
O nome padrão de uma _branch_ no Git é `master`.
Conforme você comece a criar _commits_, você recebe uma branch `master` que aponta para o último _commit_ que você fez.
Cada vez que você cria um _commit_, ela se move automaticamente.

[NOTE]
====
A _branch_ ``master'' não é especial.(((master)))
Ela é exatamente como qualquer outra.
A única razão que quase todo repositório tem uma é que o commando `git init` cria ela por padrão e a maior parte das pessoas não a muda.
====

.Uma _branch_ e seu histórico de commit
image::images/branch-and-history.png[A branch and its commit history.]

[[r_create_new_branch]]
==== Criando uma nova branch

(((branches, creating)))
O que acontece quando você cria uma nova _branch_?
Bom, fazendo isso se cria uma nova referência para que você se mova.
Digamos que você crie uma nova _branch_ chamada testing.
Você faz isso com o commando `git branch`:(((git commands, branch)))

[source,console]
----
$ git branch testing
----

Isso cria uma nova referência para o mesmo _commit_ que você está atualmente.

.Duas branches apontando para a mesma série de commits.
image::images/two-branches.png[Two branches pointing into the same series of commits.]

Como o Git sabe em que _branch_ estamos?
Ele mantém uma referência especial chamada `HEAD`.
Note que ela é bem diferente do conceito de `HEAD` em outros sistemas de controle de versão que você talvez esteja acostumado, como o Subversion ou o CVS.
No Git, esta é uma referência especial para a _branch_ local em que você está no momento.
Neste caso, você ainda está na `master`.
O comando `git branch` apenas _criou_ uma nova _branch_. Ele não mudou de posição para ela.

.HEAD apontando para uma _branch_
image::images/head-to-master.png[HEAD pointing to a branch.]

Você pode ver facilmente isso executando um simples comando `git log` que mostra para onde as referências das _branches_ estão apontando.
Essa opção é chamada `--decorate`.

[source,console]
----
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to the central interface
34ac2 Fixed bug #1328 - stack overflow under certain conditions
98ca9 The initial commit of my project
----

Você pode ver que as _branches_ ``master'' e ``testing'' estão juntas ao _commit_ `f30ab`.

[[r_switching_branches]]
==== Alternando entre _branches_

(((branches, switching)))
Para alternar para uma _branch_ existente, você deve executar o comando `git checkout`.(((git commands, checkout)))
Vamos alternar para a nova _branch_ `testing`:

[source,console]
----
$ git checkout testing
----

Isso move a `HEAD` para que aponte para a _branch_ `testing`.

.HEAD aponta para a _branch_ atual
image::images/head-to-testing.png[HEAD points to the current branch.]

O que isso significa?
Bom, façamos outro _commit_:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made a change'
----

.A _branch_ da HEAD se move para a frente quando um _commit_ é feito
image::images/advance-testing.png[The HEAD branch moves forward when a commit is made.]

Isto é interessante, já que agora a _branch_ `testing` se moveu para a frente, mas a `master` ainda aponta para o _commit_ em que estava quando você executou `git checkout` para alternar entre _branches_.
Voltemos à _branch_ `master`:

[source,console]
----
$ git checkout master
----

.HEAD se move quando você executa `git checkout`
image::images/checkout-master.png[HEAD moves when you checkout.]

Esse comando fez duas coisas.
Ele moveu a referência da HEAD de volta à `master`, e reverteu os arquivos no seu diretório de trabalho de volta ao _snapshot_ para a qual a `master` aponta.
Isso também significa que as alterações que você faça a partir deste ponto irão divergir da versão antiga do projeto.
Isso basicamente retrocede o trabalho que você fez em `testing` de forma que você pode seguir em uma direção diferente.

[NOTE]
.Alternar entre _branches_ muda os arquivos em seu diretório de trabalho
====
É importante notar que quando você alterna entre _branches_ no Git, os arquivos em seu diretório de trabalho irão mudar.
Se você alternar para uma _branch_ mais antiga, seu diretório de trabalho será revertido de forma que ele seja igual ele era na última vez que você fez um _commit_ nessa _branch_.
Se o Git não conseguir fazer isso de forma limpa, ele não irá deixar você alternar completamente.
====

Vamos fazer algumas alterações e criar um novo _commit_:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made other changes'
----

Agora o histórico de seu projeto divergiu (see <<rdivergent_history>>).
Você criou e alternou para uma _branch_, trabalhou um pouco nela, e então voltou para sua _branch_ principal e fez outro trabalho.
Ambas as alterações estão isoladas em _branches_ separadas: você pode ir e voltar entre as _branches_ e mesclá-las assim que puder.
E você fez isso simplesmente com os comandos `branch`, `checkout` e `commit`.

[[rdivergent_history]]
.Histórico divergente
image::images/advance-master.png[Divergent history.]

Você pode ver isso facilmente com o comando `git log`.
Se você executar `git log --oneline --decorate --graph --all`, ele irá mostrar o histórico de seus commits, mostrando onde estão as referências de suas _branches_ e como o histórico divergiu.

[source,console]
----
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
----

Como uma _branch_ no Git é na verdade um simples arquivo que contém o _checksum_ SHA-1 de 40 caracteres do _commit_ a que se refere, _branches_ são baratas de se criar e destruir.
Criar uma nova _branch_ tão é rápido e simples quanto escrever 41 bytes em um arquivo (40 carateres e uma nova linha).

Isso é um claro contraste com a forma que a maior parte das ferramentas mais antigas de controle lidavam com _branches_, que envolviam copiar todos os arquivos do projeto em um diretório secundário.
Isso podia levar vários segundos ou até minutos, dependendo do tamanho do projeto, enquanto no Git o processo é sempre instantâneo.
Além disso, como lembramos dos pais quando criamos um _commit_, uma base adequada para mesclagem é encontrada automaticamente para nós e geralmente é algo bem fácil de se fazer.
Esses recursos ajudam os desenvolvedores a criar _branches_ e usá-las frequentemente.

Vamos ver porque você deveria fazer isso.
